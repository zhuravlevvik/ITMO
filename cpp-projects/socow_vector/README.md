# vector со small-object и copy-on-write оптимизациями

В этом проекте реализован класс аналогичный `std::vector`, но имеющий *small-object* и *copy-on-write* оптимизации.

*small-object* предполагает, что вектор умеет хранить небольшое число элементов без динамической аллокации памяти. *copy-on-write* предполагает, что копирование/присваивание больших векторов не копирует все элементы само, а откладывает копирование элементов до момента когда к объекту применят модифицирующую операцию.

Из-за наличия  *small-object* и *copy-on-write* оптимизаций, некоторые операции имеют другую вычислительную сложность и/или предоставляют другую гарантию безопасности исключений:

* Конструктор копирования и оператор присваивания работают за `O(SMALL_SIZE)`, а не за `O(size)`.
* Если размеры и `a` и `b` меньше `SMALL_SIZE`, `swap(a, b)` предоставляет базовую гарантию безопасности исключений, иначе – сильную.
* Если размеры и `a` и `b` меньше `SMALL_SIZE`, `a = b` предоставляет базовую гарантию безопасности исключений, иначе – сильную.
* Неконстантные операции `operator[]`, `data()`, `front()`, `back()`, `pop_back()`, `begin()`, `end()` работают за O(size) и удовлетворять сильной гарантии безопасности исключений, если требуется копирование для *copy-on-write*, и за O(1) и nothrow иначе.
* Как и со стандартным вектором, `reserve` гарантирует, что после выполения `reserve(n)` вставки в вектор не будут приводить к переаллокациям, пока размер <= `n`.

